# React ??

## 1.React 란?

React는 사용자 인터페이스를 구축하기 위한 선언적이고 효율적이며 유연한 자바스크립트 라이브러리다.
컴포넌트라는 작고 고립된 코드의 파편을 이용하여 복잡한 UI를 구성하도록 돕는다.

## state를 갖는 방법

React 컴포넌트는 **생성자**에 **this.state**를 설정하는것으로 state를 가질수 있다.
**this.state** 는 정의된 React 컴포넌트에 대해 비공개로간주 , 

```js
//ex) 
class Square extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: null,
    };
  }
```

### 주의!!
JavaScript 클래스에서 하위 클래스의 생성자를 정의할 때 항상 super를 호출해야합니다. 모든 React 컴포넌트 클래스는 생성자를 가질 때 super(props) 호출 구문부터 작성해야 합니다.

## 2.React가 렌더링을 실행하는 과정

react 컴포넌트가 렌더링을 실행하는 시점은 다음과 같다

1. pros가 변경되었을때
2. state가 변경되었을때
3. forceUpdate() 를 실행하였을때
4. 부모 컴포넌트가 렌더링 되었을때

하지만 불필요한 렌더링으로 성능손실이 발생 할 수 있는데 그때 사용하는 메소드가 

**shouldComponentUpdate** 라는 라이프 사이클 메서드이다.
이 라이프사이클 메서드를 정의하면 컴포넌트 렌더링을 제어할 수 있다.
데이터가 변경되어 렌더링 작업을 필요할 경우 렌더링 작업을 수행할수있다


## 3. state 끌어올리기

여러개의 자식으로부터 데이터를 모으거나 두개의 자식 컴포넌트들이 서로 통신하게 하려면 부모 컴포넌트에 **공유state**를 정의해야함 
부모컴포넌트는 **props**를 사용하여 자식 컴포넌트에 state를 다시 전달할 수 있습니다.
이것은 자식 컴포넌트들이 서로 또는 부모 컴포넌트와 동기화 하도록 만들 수 있음


## 4. 불변성이 중요한 이유?

기존 배열을 수정하는 것이 아니라 .slice() 연산자를 사용하여 배열의 사본만들기를 추천했음.
일반적으로 데이터 변경에는 두가지방법이 있다.
1. 데이터의 값을 직접변경
2. 원하는 변경값을 가진 새로운 사본으로 데이터를 교체

### 객체 변경을 통해 데이터 수정하기
```js
var player = {score: 1, name: 'Jeff'};
player.score = 2;
//이제 player는 {score : 2 , name: 'Jeff'} 이다.
```

### 객체 변경 없이 데이터 수정하기
```js
var player = {score: 1 , name: 'Jeff'};

var newPlayer = Object.assign({}, player, {score:2});
// 이제 player는 변하지 않았지만 newPlayer는 {score:2 , name: 'Jeff'}이다

// 만약 객체 spread 구문(전개구문)을 사용한다면 이렇게 쓸 수 있습니다.
// var newPlayer = {...player , score: 2};
```

+ 객체 변경이나 기본 데이터의 변경을 하지않는다면 이점
 - **복잡한 특징들을 단순하게**
   직접적인 데이터변이를 피함 이전버전의 이력을 유지하고 나중에 재사용
 - **변화를 감지**
   객체가 직접적으로 수정되기때문에 변화를 감지하는것은 어렵다
   감지는 복제가 가능한 객체를 이전 사본과 비교하고 전체 객체 트리를 돌아야함

   불변객체서 감지하는것은 상당히 쉽다.
 - **React에서 다시 렌더링하는 시기를 결정**  
   불변성의 가장 큰 장점은 React에서 순수 컴포넌트를 만드는데 도움을 준다.
   변하지않는 데이터의 변경이 이루어졌는지 쉽게 판단하고 컴퓨터가 다시 렌더링할지 결정함.

   그래서 **shouldComponentUpdate()** 를 이용하면 성능을 최적화할수있다.


 ## 5. 함수 컴포넌트

 함수 컴포넌트는 더 간단하게 컴포넌트를 작성하는 방법이고 
 - state 없이 **render**함수만을 가짐
 - **React.Component**를 확장하는 클래스를 정의하는 대신 **props**를 입력받아서 
   렌더링할 대상을 반환하는 함수를 작성할 수 있다.


 **주의**
 배열 push() 함수와 같이 더 익숙한 방식과 달리 concat() 함수는 기존 배열을 복제하지 않기 때문에 이를 더 권장

 경고 배열이나 이터레이터의 자식들은 고유의 “key” prop을 가지고 있어야 합니다. “Game”의 render 함수를 확인해주세요.